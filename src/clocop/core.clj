(ns clocop.core
  (:import (JaCoP.core Store
                       IntVar
                       IntDomain
                       IntervalDomain
                       BoundDomain)
           (JaCoP.search DepthFirstSearch
                         InputOrderSelect
                         IndomainMin
                         )))

(defn ^Store store
  "Makes a JaCoP \"Store\" object, which is the key concept in constraint programming.
No options and configurations are required for the Store itself, but you will connect all the variables, constraints, and searchers to it eventually."
  []
  (Store.))

(defn ^IntDomain domain
  "Takes an arbitrary number of [min max] pairs. This function is more capable than simply entering a single min and max value in the int-var function."
  [& min-max-pairs]
  (let [domains (for [[min max] min-max-pairs]
                  (IntervalDomain. min max))
        [the-domain & other-domains] domains]
    (doseq [other-domain other-domains]
      (.addDom the-domain other-domain))
    the-domain))

(defn ^IntVar int-var
  "Creates a JaCoP \"IntVar\" object, which can have constraints on it. Must be connected to a Store object at the time of creation.

Allowed argument lists:
- (int-var store min max)
- (int-var store name min max)
- (int-var store domain)
- (int-var store name domain)

Note that the optional \"name\" field (which is an input-order-select by default) is only used for the outputted logs, and not at all necessary to function internally."
  [store & args]
  (case (count args)
    1 (IntVar. store (first args))
    2 (IntVar. store (first args) (second args))
    3 (IntVar. store (first args) (second args) (nth args 2))))

(defn solve
  "Given a store and some constraints, finds one (or every) solution. Solutions are returned in the form of a map, from the var names to their values.
Optional keyword arguments:
:solutions - :one or :all (default :one)
:selector - a selector created via clocop.solver. Automatically generated by default.
:vars-to-return - a set of the variable names that you want to be in the result map. (All of them by default)
:minimize - an int-var that the search will minimize as much as possible.

NOTE: Weird behavior occurs when reusing stores and constraints.
"
  [store constraints & {:as args}]
  (let [_ (doseq [constraint constraints]
            (.impose store constraint))
        num-solutions (or (:solutions args) :one)
        selector (or (:selector args)
                     (InputOrderSelect. store (.vars store) (IndomainMin.)))
        vars-to-return (or (:vars-to-return args) (fn [arg] true))
        minimize (:minimize args)
        search (DepthFirstSearch.)
        listener (.getSolutionListener search)
        _ (.setPrintInfo search false)
        _ (when (= num-solutions :all)
            (.searchAll listener true))
        _ (when minimize
            (.setOptimize search true)
            (.setCostVar search minimize))
        _ (.recordSolutions listener true)
        labeling? (.labeling search store selector)
        ]
    (cond
      (not labeling?) nil
      :else (let [solutions (for [i (range 1 (inc (.solutionsNo listener)))
                                  :let [domain-array (.getSolution listener i)]]
                              (let [vars (.getVariables listener)
                                    varnames (map #(.id %) vars)
                                    domain-vals (for [domain domain-array]
                                                  (.getElementAt domain 0))
                                    result (zipmap varnames domain-vals)]
                                (into {} (for [[k v] result :when (vars-to-return k)]
                                           [k v]))))]
              
              (if (= num-solutions :one)
                (first solutions)
                solutions)))))

;(def s (store))
;(def vars [(int-var s "a" 1 2)
;           (int-var s "b" 3 4)])
;(def constraints [(clocop.constraints/=% (vars 0) 1)
;                  (clocop.constraints/=% (vars 1) 4)])